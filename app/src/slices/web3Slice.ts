import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState, AppThunk } from "../store/store";
import {
  Keypair,
  SystemProgram,
  Transaction,
  PublicKey,
  Connection,
} from "@solana/web3.js";
import * as web3 from "@solana/web3.js";
import * as splToken from "@solana/spl-token";
import { getTokenListRequest, getTokensOfAccountRequest } from "../api/web3";
import { WalletAdapterNetwork } from "@solana/wallet-adapter-base";

// TODO: fix ts errors in formdata on responess

export interface Web3State {
  walletKey: string;
  mintStatus: string;
  tokenList: Array<any>;
  network: WalletAdapterNetwork;
}

const initialState: Web3State = {
  walletKey: "",
  mintStatus: "idle",
  tokenList: [],
  network: WalletAdapterNetwork.Devnet,
};

interface IMintToken {
  publicKey: PublicKey;
  connection: Connection;
}

export const mintToken = createAsyncThunk(
  "web3/mintToken",
  async ({ publicKey, connection }: IMintToken) => {
    if (!publicKey) {
      console.log("no public key", publicKey);
      // throw new WalletNotConnectedError();
      return;
    }

    // TODO: use users wallet...temp to create new wallet and get airdrop
    var fromWallet = web3.Keypair.generate();
    var fromAirdropSignature = await connection.requestAirdrop(
      fromWallet.publicKey,
      web3.LAMPORTS_PER_SOL
    );
    //wait for airdrop confirmation
    await connection.confirmTransaction(fromAirdropSignature);

    let mint = await splToken.Token.createMint(
      connection, // connection to solana network
      fromWallet, // wallet that pays the fee
      fromWallet.publicKey, // wallet that has authority to mint ttokens
      null, // wallet with authority to freeze tokens (optional)
      9, // amount of decimals
      splToken.TOKEN_PROGRAM_ID // program id of token - https://docs.solana.com/developing/programming-model/transactions#program-id
    );

    // fetches account associated with the public key. Tokens reside in account... wallet owns account
    const fromTokenAccount = await mint.getOrCreateAssociatedAccountInfo(
      fromWallet.publicKey
    );

    const toTokenAccount = await mint.getOrCreateAssociatedAccountInfo(
      publicKey
    );

    await mint.mintTo(
      fromTokenAccount.address, //who it goes to
      fromWallet.publicKey, // minting authority
      [], // multisig
      1000000000 // how many
    );

    await mint.setAuthority(
      mint.publicKey,
      null,
      "MintTokens",
      fromWallet.publicKey,
      []
    );

    // Add token transfer instructions to transaction
    const transaction = new web3.Transaction().add(
      splToken.Token.createTransferInstruction(
        splToken.TOKEN_PROGRAM_ID,
        fromTokenAccount.address,
        toTokenAccount.address,
        fromWallet.publicKey,
        [],
        1
      )
    );

    // // Sign transaction, broadcast, and confirm
    const signature = await web3.sendAndConfirmTransaction(
      connection,
      transaction,
      [fromWallet],
      { commitment: "confirmed" }
    );
    console.log("SIGNATURE", signature);
  }
);

export const getTokenList = createAsyncThunk("web3/getTokenList", async () => {
  return getTokenListRequest();
});

export const getTokensOfAccount = createAsyncThunk(
  "web3/getTokensOfAccount",
  async (publicKey: string) => {
    return getTokensOfAccountRequest(publicKey);
  }
);

export const web3Slice = createSlice({
  name: "web3",
  initialState,
  reducers: {
    selectNetwork: (state, action: PayloadAction<WalletAdapterNetwork>) => {
      state.network = action.payload;
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(mintToken.pending, (state) => {
        state.mintStatus = "loading";
      })
      .addCase(mintToken.rejected, (state) => {
        state.mintStatus = "failed";
      })
      .addCase(mintToken.fulfilled, (state, action: any) => {
        state.mintStatus = "idle";
      })
      .addCase(getTokenList.fulfilled, (state, action: any) => {
        state.tokenList = action.payload;
      });
  },
});

export const { selectNetwork } = web3Slice.actions;

export default web3Slice.reducer;
